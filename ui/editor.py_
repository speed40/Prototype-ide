# editor.py
# This file has been updated to explicitly set the ScrollView for the LineNumber widget.

from kivy.animation import Animation
from kivy.core.window import Window
from kivy.metrics import dp, sp
from kivy.properties import (StringProperty, NumericProperty,
                           BooleanProperty, ObjectProperty)
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.textinput import TextInput
from kivy.uix.boxlayout import BoxLayout
from kivy.logger import Logger

from kivymd.app import MDApp
from kivymd.uix.label import MDLabel
from kivymd.theming import ThemableBehavior

from ui.utilities.history_manager import HistoryManager
from ui.utilities.line_number import LineNumber

# Import Clock here if not imported elsewhere in the file (needed for schedule_once in fallback)
from kivy.clock import Clock


class CodeInput(TextInput, ThemableBehavior):
    """
    The core text input widget for the code editor.
    Dynamically adjusts its height based on content while maintaining minimum line count.
    Adds auto-pairing and smart deletion for common characters.
    """
    line_limit = NumericProperty(15)  # Minimum number of lines to show
    line_height = NumericProperty(sp(20))  # Default line height in pixels
    is_overflowing = BooleanProperty(False)  # Track if content overflows initial height

    AUTO_PAIRS = {
        '(': ')', '[': ']', '{': '}',
        '"': '"', "'": "'", '`': '`', '<': '>'
    }
    AUTO_CLOSE_CHARS = {')', ']', '}', '"', "'", '`', '>'}

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.multiline = True
        self.write_tab = False
        self.padding = [dp(10), dp(10), dp(10), dp(10)]
        self.base_direction = 'ltr'
        self.hint_text = ''
        self.size_hint_y = None

        self.min_height = (self.line_height * self.line_limit) + self.padding[1] + self.padding[3]
        self.height = self.min_height
        self.initial_height = self.min_height

        self.bind(
            _lines=self._update_height_from_lines,
            line_limit=self._update_min_height_property,
            line_height=self._update_min_height_property,
        )

        app = MDApp.get_running_app()
        if app and hasattr(app, 'theme_cls'):
            app.theme_cls.bind(
                theme_style=self._update_theme_colors,
                primary_palette=self._update_theme_colors
            )
        self._update_theme_colors()

    def _update_theme_colors(self, *args):
        app = MDApp.get_running_app()
        if not app or not hasattr(app, 'theme_cls'):
            return
        theme_cls = app.theme_cls
        is_dark = theme_cls.theme_style == "Dark"

        try:
            self.background_color = theme_cls.bg_dark if is_dark else theme_cls.bg_light
            self.foreground_color = theme_cls.text_color
            self.cursor_color = theme_cls.primary_color
            self.selection_color = [*theme_cls.primary_color[:3], 0.5]
            self.hint_text_color = theme_cls.disabled_hint_text_color
        except AttributeError as e:
            Logger.warning(f"CodeInput: Theme attribute not found during _update_theme_colors: {e}")

    def _update_min_height_property(self, *args):
        self.min_height = (self.line_height * self.line_limit) + self.padding[1] + self.padding[3]
        self.initial_height = self.min_height
        self._update_height_from_lines()

    def _update_height_from_lines(self, *args):
        physical_lines_count = max(len(self._lines), 1)
        required_height = (self.line_height * physical_lines_count) + self.padding[1] + self.padding[3]
        new_height = max(required_height, self.min_height)

        if self.height != new_height:
            self.height = new_height

        self.is_overflowing = (required_height > self.initial_height)

    def insert_text(self, substring, from_undo=False):
        if len(substring) == 1 and not from_undo:
            if substring in self.AUTO_PAIRS:
                closing_char = self.AUTO_PAIRS[substring]
                super().insert_text(substring + closing_char, from_undo=from_undo)
                self.cursor = self.get_cursor_from_index(self.cursor_index() - 1)
                return
            elif substring in self.AUTO_CLOSE_CHARS:
                cursor_col, cursor_row = self.cursor
                try:
                    next_char = self.text[self.cursor_index()]
                    if next_char == substring:
                        self.cursor = (cursor_col + 1, cursor_row)
                        return
                except IndexError:
                    pass

        super().insert_text(substring, from_undo=from_undo)

    def do_backspace(self, from_undo=False, mode='bkspc'):
        if not self.selection_text and not from_undo:
            cursor_idx = self.cursor_index()
            if cursor_idx > 0:
                char_before = self.text[cursor_idx - 1]
                try:
                    char_after = self.text[cursor_idx]
                    if char_before in self.AUTO_PAIRS and self.AUTO_PAIRS[char_before] == char_after:
                        super().do_backspace(from_undo=from_undo, mode=mode)
                        super().do_backspace(from_undo=from_undo, mode='del')
                        return
                except IndexError:
                    pass
        super().do_backspace(from_undo=from_undo, mode=mode)


class CodeEditor(FloatLayout):
    intro_text = StringProperty("Type code here...")
    app_clock = ObjectProperty(None) # Make sure you pass Clock=Clock when creating this widget!
    initial_min_line_count = NumericProperty(15)
    _calculated_initial_min_height = NumericProperty(0)

    def __init__(self, app_clock=None, **kwargs):
        super().__init__(**kwargs)
        # Assign the provided clock instance (from kivy.clock.Clock)
        self.app_clock = app_clock if app_clock is not None else Clock # Fallback to main Clock if not provided

        self.history_manager = HistoryManager(app_clock=self.app_clock)
        self._setup_ui()

    def _setup_ui(self):
        self.container = BoxLayout(
            orientation='vertical',
            size_hint=(1, None),
            spacing=dp(10)
        )
        self.add_widget(self.container)

        self.intro_label = MDLabel(
            text=self.intro_text,
            size_hint=(1, None),
            height=dp(30),
            halign="center",
            theme_text_color="Hint",
            font_style="Caption",
            opacity=1
        )
        self.container.add_widget(self.intro_label)

        self.editor_area_layout = BoxLayout(
            orientation='horizontal',
            size_hint=(1, None),
        )
        self.container.add_widget(self.editor_area_layout)

        self.code_input = CodeInput(
            size_hint=(1, None),
            line_limit=self.initial_min_line_count
        )

        self.line_number_gutter = LineNumber(text_input=self.code_input)
        self.editor_area_layout.add_widget(self.line_number_gutter)

        self.scroll_view = ScrollView(
            size_hint=(1, None),
            bar_width=dp(4),
            scroll_type=['bars', 'content']
        )
        self.scroll_view.add_widget(self.code_input)
        self.editor_area_layout.add_widget(self.scroll_view)

        # Explicitly set the ScrollView for the LineNumber widget
        # This line caused an AttributeError as LineNumber has no set_scroll_view method.
        # The LineNumber class should find the ScrollView parent automatically via its _sync_scroll method
        # if the CodeInput is added as a child of the ScrollView, which it is.
        # if hasattr(self, 'line_number_gutter') and hasattr(self, 'scroll_view'):
        #      self.line_number_gutter.set_scroll_view(self.scroll_view)

        # Manually trigger the scroll synchronization after adding code_input to scroll_view
        # Scheduling it slightly after to give the widget tree time to settle and parent relationships to finalize.
        # This should help LineNumber find its ScrollView parent reliably, addressing the warning.
        if hasattr(self, 'line_number_gutter') and hasattr(self.code_input, 'parent'):
             # Check if the parent is already set correctly before scheduling
             if self.code_input.parent is self.scroll_view:
                 # This schedules _trigger_line_number_update, which in turn schedules _update_line_numbers
                 # Schedule this initial sync for the next frame (0 delay)
                 self.app_clock.schedule_once(
                      lambda dt: self.line_number_gutter._sync_scroll(self.code_input, self.code_input.parent),
                      0 # Schedule it for the next available frame
                 )
             else:
                  # If parent isn't the scroll view immediately, the binding on parent should still hopefully work,
                  # but logging a warning just in case.
                  Logger.warning("CodeEditor: code_input's parent not set to scroll_view immediately in _setup_ui. Relying on LineNumber's parent binding.")


        self.code_input.bind(
            text=self._on_text_change,
            height=self._update_editor_components_height,
            is_overflowing=self._on_overflow_change
        )

        # --- START NEW BINDING FOR INITIAL STABILITY ---
        # Bind to the scroll_view's size property to trigger LineNumber update
        # after the ScrollView's dimensions are set during initial layout.
        if hasattr(self, 'line_number_gutter') and hasattr(self, 'scroll_view'):
             # When scroll_view size changes, trigger LineNumber update (which is scheduled)
             # Pass the scroll_view instance and its size to the lambda, though we only need the trigger.
             self.scroll_view.bind(size=lambda instance, value: self.line_number_gutter._trigger_line_number_update())
        # --- END NEW BINDING ---


        # We still need this initial height calculation triggered after kv (keep this with the increased delay)
        if self.app_clock:
            # Schedule the initial height calculation. This method also schedules the first LineNumber update.
            self.app_clock.schedule_once(self._initialize_heights, 0.1) # Keep the initial height check delay
        else:
            # Fallback to window bind if no clock, less reliable
            Window.bind(on_kv_post=self._initialize_heights_from_kv)
            Logger.warning("CodeEditor: app_clock not provided. Initial height may depend on on_kv_post.")


    def _initialize_heights_from_kv(self, *args):
        Window.unbind(on_kv_post=self._initialize_heights_from_kv)
        self._initialize_heights()

    def _initialize_heights(self, dt=None):
        # Added a check to make sure line_number_gutter is initialized before trying to trigger its update
        if hasattr(self.code_input, 'line_height') and self.code_input.line_height > 0 and self.code_input.min_height > 0:
            self._calculated_initial_min_height = self.code_input.min_height
            self._update_editor_components_height(self.code_input, self.code_input.height)
            # Only trigger line number update if it exists AND code_input has a parent (like the scroll view)
            if hasattr(self, 'line_number_gutter') and hasattr(self.code_input, 'parent') and self.code_input.parent is not None:
                # --- START DELAY ADJUSTMENT ---
                # Increase the delay for the initial LineNumber update to give layout more time to settle.
                # This update will be scheduled via _trigger_line_number_update, which schedules _update_line_numbers.
                if self.app_clock:
                     # Use a slightly longer delay for the very first LineNumber draw based on settled layout
                     self.app_clock.schedule_once(lambda dt: self.line_number_gutter._trigger_line_number_update(), 0.4) # Increased delay further
                else:
                     # Fallback direct call might still have issues without clock
                     Logger.warning("CodeEditor: app_clock not available for scheduled initial LineNumber update. Calling directly.")
                     self.line_number_gutter._trigger_line_number_update()
                # --- END DELAY ADJUSTMENT ---
        elif self.app_clock:
             # Reschedule the height initialization check if needed, but only if we have a clock
             self.app_clock.schedule_once(self._initialize_heights, 0.1) # Keep the check retry delay
        else:
             # Log if fallback initialization might fail
             Logger.warning("CodeEditor: _initialize_heights potentially failing due to lack of app_clock or missing properties.")


    def _update_editor_components_height(self, instance, text_input_height):
        target_editor_comp_height = max(text_input_height, self._calculated_initial_min_height)

        # Calculate max_scrollable_height based on parent height
        max_scrollable_height = Window.height * 0.7 # Default fallback
        if self.parent:
             # Consider parent height and intro label/spacing
             # Ensure parent height is valid
             if self.parent.height > 0:
                 max_scrollable_height = self.parent.height - self.intro_label.height - self.container.spacing
                 # Ensure it doesn't go below a certain threshold or become negative
                 max_scrollable_height = max(max_scrollable_height, self.code_input.min_height)
             else:
                 # Fallback if parent height is not yet determined
                 max_scrollable_height = self.code_input.min_height * 5 # Arbitrary large enough number


        effective_editor_comp_height = min(target_editor_comp_height, max_scrollable_height)
        if effective_editor_comp_height <= 0:
            effective_editor_comp_height = self.code_input.min_height
            # Logger.warning(f"CodeEditor: effective_editor_comp_height calculated to 0 or less. Falling back to min_height: {effective_editor_comp_height}") # Debugging height issues


        if self.scroll_view.height != effective_editor_comp_height:
            self.scroll_view.height = effective_editor_comp_height
            # Logger.info(f"CodeEditor: Setting ScrollView height to {effective_editor_comp_height}") # Added Log

        # Ensure LineNumber gutter height matches ScrollView height
        if hasattr(self, 'line_number_gutter'):
            if self.line_number_gutter.height != self.scroll_view.height:
                self.line_number_gutter.height = self.scroll_view.height
                # Logger.info(f"CodeEditor: Setting LineNumber gutter height to {self.line_number_gutter.height}") # Added Log

        if self.editor_area_layout.height != self.scroll_view.height:
            self.editor_area_layout.height = self.scroll_view.height
            # Logger.info(f"CodeEditor: Setting editor_area_layout height to {self.editor_area_layout.height}") # Added Log


        new_container_height = self.intro_label.height + self.editor_area_layout.height + self.container.spacing
        if self.container.height != new_container_height:
            self.container.height = new_container_height
            # Logger.info(f"CodeEditor: Setting container height to {new_container_height}") # Added Log


    def _on_text_change(self, instance, text):
        self.history_manager.add_state(text)

    def _on_overflow_change(self, instance, is_overflowing):
        if is_overflowing and self.intro_label.opacity > 0:
            Animation(opacity=0, duration=0.3).start(self.intro_label)
        elif not is_overflowing and self.intro_label.opacity < 1 and self.intro_label.text:
            Animation(opacity=1, duration=0.3).start(self.intro_label)

    def set_intro_message(self, text):
        self.intro_text = text
        if hasattr(self, 'intro_label'):
            self.intro_label.text = text
            if not text and self.intro_label.opacity > 0:
                Animation(opacity=0, duration=0.3).start(self.intro_label)
            elif text and self.intro_label.opacity < 1 and not self.code_input.is_overflowing:
                Animation(opacity=1, duration=0.3).start(self.intro_label)

    def undo(self):
        state = self.history_manager.undo()
        if state is not None:
            self.code_input.text = state
            # Attempt to maintain cursor position relative to the end of the text
            self.code_input.cursor = self.code_input.get_cursor_from_index(len(state))


    def redo(self):
        state = self.history_manager.redo()
        if state is not None:
            self.code_input.text = state
            # Attempt to maintain cursor position relative to the end of the text
            self.code_input.cursor = self.code_input.get_cursor_from_index(len(state))


    def cleanup(self):
        self.history_manager.cleanup()
        if hasattr(self, 'line_number_gutter'):
            pass # Add any necessary cleanup for line_number_gutter here